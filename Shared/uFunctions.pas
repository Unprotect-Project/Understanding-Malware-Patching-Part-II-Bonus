{******************************************************************************}
{                                                                              }
{                                                                              }
{                   Author: DarkCoderSc (Jean-Pierre LESUEUR)                  }
{                   https://www.twitter.com/darkcodersc                        }
{                   https://www.unprotect.it/                                  }
{                   https://github.com/Unprotect-Project                       }
{                   https://github.com/darkcodersc                             }
{                   https://github.com/PhrozenIO                               }
{                   License: Apache License 2.0                                }
{                                                                              }
{                                                                              }
{******************************************************************************}


unit uFunctions;

interface

uses System.Classes,
     System.SysUtils,
     System.Math,
     Winapi.Windows;

function BufferToHexView(const pBuffer : PVOID; const ABufferSize : UInt64) : String;
function FormatSize(const ASize : UInt64) : string;

implementation

{ _.BufferToHexView }
function BufferToHexView(const pBuffer : PVOID; const ABufferSize : UInt64) : String;
var ARow           : array of byte;
    AStringBuilder : TStringBuilder;
    AHexBuilder    : TStringBuilder;
    AAsciiBuilder  : TStringBuilder;

    function PrintChar(const AChar : Byte) : Char;
    begin
      if AChar in [32..126] then
        result := Chr(AChar)
      else
        result := '.';
    end;

const SPACE = #32;

begin
  result := '';
  ///

  AStringBuilder := TStringBuilder.Create();
  AHexBuilder := TStringBuilder.Create(48);
  AAsciiBuilder := TStringBuilder.Create(16);
  try
    var ABytesRead : UInt64 := 0;

    SetLength(ARow, 16);
    repeat
      if ABufferSize - ABytesRead < 16 then
        SetLength(ARow, ABufferSize - ABytesRead);
      ///

      CopyMemory(PByte(ARow), Pointer(NativeUInt(pBuffer) + ABytesRead), Length(ARow));

      AHexBuilder.Clear();
      AAsciiBuilder.Clear();

      for var x := 0 to Length(ARow) -1 do begin
        AHexBuilder.Append(SPACE + IntToHex(ARow[x]));
        AAsciiBuilder.Append(PrintChar(ARow[x]));
      end;

      AStringBuilder.AppendLine(
        Format('%p:%p %-48s %s', [
          Pointer(NativeUInt(pBuffer) + ABytesRead),
          Pointer(ABytesRead),
          AHexBuilder.ToString(),
          AAsciiBuilder.ToString()
        ])
      );

      ///
      Inc(ABytesRead, Length(ARow));
    until ABytesRead = ABufferSize;

    ///
    result := AStringBuilder.ToString();
  finally
    if Assigned(AStringBuilder) then
      FreeAndNil(AStringBuilder);

    if Assigned(AHexBuilder) then
      FreeAndNil(AHexBuilder);

    if Assigned(AAsciiBuilder) then
      FreeAndNil(AAsciiBuilder);
  end;
end;

{ _.FormatSize }
function FormatSize(const ASize : UInt64) : string;
const AByteDescription : Array[0..8] of string = (
                                                    'Bytes',
                                                    'KiB',
                                                    'MB',
                                                    'GiB',
                                                    'TB',
                                                    'PB',
                                                    'EB',
                                                    'ZB',
                                                    'YB'
                                                  );
begin
  var ACount : UInt64 := 0;

  while ASize > Power(1024, ACount +1) do
    Inc(ACount);

  result := Format('%s %s', [
                              FormatFloat('###0.00', ASize / Power(1024, ACount)),
                              AByteDescription[ACount]
  ]);
end;

end.
